Entities_Actions:
	LD A, $mem_moving_animation_step
	CP $05
	JR NZ, =.Action_Functions
	CALL =Reset_Entities_Collision_Map

	.Action_Functions:
	LD HL, $mem_entities_list
	CALL =Entity_Action
	CALL =Entity_Action
	CALL =Entity_Action
	CALL =Entity_Action
	CALL =Entity_Action
	CALL =Entity_Action
	CALL =Entity_Action
	CALL =Entity_Action
	CALL =Entity_Action
	CALL =Entity_Action
	CALL =Entity_Action
	CALL =Entity_Action
	CALL =Entity_Action
	CALL =Entity_Action
	CALL =Entity_Action
	CALL =Entity_Action
	RET

Entity_Action:
	LD A, (HL+)
	CP $00
	JR Z, =.skip

	INC HL
	INC HL
	INC HL

	LD E, (HL)
	PUSH HL

	LD A, L
	AND $f0
	LD L, A

	LD BC, =Turn_Jump_table
	LD A, E

	.JUMP_TABLE

	POP HL

	.skip:
	LD A, L
	AND $f0
	ADD $10
	LD L, A
	RET

Update_Animation_Steps:
	LD A, $mem_map_loading_flags
	BIT 3, A
	JR Z, =.update_mode

	LD A, $mem_moving_animation_step
	INC A
	AND $0f
	LD $mem_moving_animation_step, A

	CP $00
	JR NZ, =.end

	LD A, $mem_map_loading_flags
	RES 3, A
	SET 1, A
	LD $mem_map_loading_flags, A

	.update_mode:

	LD A, $mem_requested_mode
	LD $mem_current_mode, A

	.end:
	LD A, $mem_bunny_health
	CP $00
	JR Z =.Dead_mode

	RET

	.Dead_mode:

	LD A, $20
	LD $mem_bunny_direction, A

	LD A, $enum_dead_mode
	LD $mem_current_mode, A

	.CLOSE_DIALOGUE

	RET

Turn_Jump_table:
	; 00
	RET
	NOP
	NOP
	NOP

	; 01
	JP =Move_Bunny
	NOP

	; 02
	JP =Fox_Turn
	NOP

Interaction_Jump_table:
	; 00
	RET
	NOP
	NOP
	NOP

	; 01
	JP =Fox_Interaction
	NOP

	; 02
	JP =Open_Dialogue
	NOP

Fox_Interaction:
	LD A, L
	AND $f0
	ADD $06
	LD L, A
	LD A, (HL)
	DEC A
	DAA
	LD (HL), A
	RET

Open_Dialogue:
	LD A, L
	AND $f0
	LD L, A

	INC HL

	LD A, $mem_bunny_x
	CP (HL)
	JR Z, =.Vertical_check

	.Horizontal_check:
		INC A
		CP (HL)
		JR Z, =.Left
		.Right:
			INC HL
			INC HL
			LD (HL), $enum_direction_right
			JR =.Check_end
		.Left:
			INC HL
			INC HL
			LD (HL), $enum_direction_left
			JR =.Check_end
	.Vertical_check:
		INC HL
		LD A, $mem_bunny_y
		INC A
		CP (HL)
		JR Z, =.Up
		.Down:
			INC HL
			LD (HL), $enum_direction_down
			JR =.Check_end
		.Up:
			INC HL
			LD (HL), $enum_direction_up
			JR =.Check_end
	.Check_end:

	LD HL, $dialogue_first_line
	LD BC, =Bunny_Prefix
	CALL =Print_str

	LD HL, $dialogue_third_line
	LD BC, =Text_1
	CALL =Print_str

	LD A, $07
	LD $mem_display_flag, A

	LD A, $mem_bunny_direction
	AND $0f
	LD $mem_bunny_direction, A

	LD A, $enum_dungeon_dialogue_mode
	LD $mem_requested_mode, A
	RET

Fox_Turn:
	LD A, $mem_map_loading_flags
	BIT 3, A
	RET Z

	PUSH HL
	PUSH BC
	PUSH DE
	INC HL
	LD A, (HL+)
	LD B, A
	LD A, (HL+)
	LD C, A
	LD A, (HL+)
	LD D, A

	.Health_check:
		LD A, L
		AND $f0
		ADD $06
		LD L, A

		LD A, (HL)
		CP $00
		JR NZ, =.Health_check.end

		LD A, L
		AND $f0
		LD L, A

		LD (HL), $00
		LD A, $mem_enemies_alive_count
		DEC A
		LD $mem_enemies_alive_count, A
		JP NZ, =.Skip_turn
	.Health_check.end:

	.Freeze_shiver:
		LD A, $mem_moving_animation_step
		CP $00
		JP NZ, =.Freeze_shiver.end
		LD A, L
		AND $f0
		ADD $08
		LD L, A
		LD A, $01
		CP (HL)
		JR NZ, =.Freeze_shiver.end
		LD A, D
		AND $07
		LD D, A
		CALL =RNG_Step
		CP $55
		JP NC, =.Skip_turn
		LD A, D
		OR $40
		LD D, A

		CALL =RNG_Step
		CP $55
		JP NC, =.Skip_turn

		LD A, $00
		LD (HL-), A
		RES 1, (HL)
		JP =.Skip_turn
	.Freeze_shiver.end:

	.Should_turn_be_skipped:
		LD A, L
		AND $f0
		ADD $08
		LD L, A

		BIT 0, (HL)
		JP NZ, =.Skip_turn

	.Start_action_or_movement:
		LD A, $mem_moving_animation_step
		CP $00
		JP NZ, =.Start_action_or_movement.end

		; CALL =Check_player_next_to
		CALL =Laser_sight_check
		LD A, E
		CP $00
		;JR Z, =.nyo_basic_attack
		JR =.nyo_basic_attack

		; CALL =Basic_Attack
		LD A, L
		AND $f0
		ADD $07
		LD L, A

		SET 2, (HL)

		JR =.Start_action_or_movement.end

		.nyo_basic_attack:
		CALL =Walking
	.Start_action_or_movement.end:

	.End_movement:
		LD A, $mem_moving_animation_step
		CP $0f
		JP NZ, =.End_movement.end
		LD A, D
		AND $07
		BIT 3, D
		LD D, A
		JR Z, =.End_movement.check_end_of_turn_mode_attack
		LD A, $01
		.ADD_A_TO_DIRECTION_BC

		.End_movement.check_end_of_turn_mode_attack:

		LD A, L
		AND $f0
		ADD $07
		LD L, A

		BIT 2, (HL)
		RES 2, (HL)
		JR Z, =.End_movement.end

		CALL =Laser_sight_check
		LD A, E
		CP $00
		JR Z, =.laser_sight_check_fail

		CALL =Laser_Attack

		.laser_sight_check_fail:

	.End_movement.end:

	.Skip_Turn:
	LD A, L
	AND $f0
	LD L, A
	INC HL
	LD A, B
	LD (HL+), A
	LD A, C
	LD (HL+), A
	LD A, D
	LD (HL+), A
	POP DE
	POP BC
	POP HL
	RET
