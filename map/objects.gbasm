Initialize_Objects:
	LD A, $mem_map_loading_flags
	OR $01
	LD $mem_map_loading_flags, A
	LD HL, $mem_object_list
	LD BC, $0080
	CALL =bzero
	LD HL, $mem_object_list
	CALL =Spawn_stairs
	CALL =Spawn_carrot
	RET

Spawn_object_in_random_room: ; Object tile in A, Object jump table id in E
	LD (HL+), A

	LD A, $mem_number_of_rooms
	CALL =RNG_Bound
	SLA A
	SLA A
	ADD $80
	LD C, A

	LD B, $c8

	LD A, (BC)
	LD D, A
	INC BC
	LD A, (BC)
	INC A
	CALL =RNG_Bound
	ADD D

	LD (HL+), A

	INC BC

	LD A, (BC)
	LD D, A
	INC BC
	LD A, (BC)
	INC A
	CALL =RNG_Bound
	ADD D
	LD (HL), A

	DEC HL

	LD BC, $mem_object_list
	Object_check_collisions.loop:
		LD A, (BC)
		CP $00
		JR Z, =Object_check_collisions.loop.next

		INC BC
		LD A, C
		CP L
		JR Z, =Object_check_collisions.loop.next

		LD A, (BC)
		CP (HL)
		JR NZ, =Object_check_collisions.loop.next

		INC BC
		INC HL
		LD A, (BC)
		CP (HL)
		JR NZ, =Object_check_collisions.loop.next

		DEC HL
		DEC HL
		XOR A
		LD (HL+), A
		LD (HL+), A
		LD (HL), A
		DEC HL
		DEC HL
		RET

		Object_check_collisions.loop.next:
		LD A, L
		AND $f8
		ADD $01
		LD L, A
		LD A, C
		AND $f8
		ADD $08
		LD C, A
		CP $80
		JR NZ, =Object_check_collisions.loop

	INC HL
	INC HL

	LD (HL), E
	LD A, L
	AND $f8
	ADD $08
	LD L, A
	RET

Spawn_stairs:
	LD A, $60
	LD E, $01
	JP =Spawn_object_in_random_room

Spawn_carrot:
	LD A, $64
	LD E, $02
	JP =Spawn_object_in_random_room

Object_Interaction_Jump_table:
	; 00
	RET
	NOP
	NOP
	NOP

	; 01
	JP =Stairs_action
	NOP

	; 02
	JP =Heal_Action
	NOP

Stairs_action:
	DI
	LD A, $00
	LD $reg_interrupt_flags, A
	.Wait_VBlank:
		LD A, $reg_lcd_status
		AND $03
		CP $01
		JR NZ, =.Wait_VBlank

	; LCDC
	XOR A
	LD $reg_lcd_controller, A

	CALL =Reset_Map
	JP =New_Dungeon

Heal_Action:
	LD A, $mem_bunny_health
	ADD $03
	DAA
	CP $20
	JR C, =.Set_health
	LD A, $20
	.Set_health:
	LD $mem_bunny_health, A

	PUSH BC
	LD A, $mem_bunny_x
	LD B, A
	LD A, $mem_bunny_y
	LD C, A
	LD A, $01
	CALL =Try_Launch_Animation
	POP BC

	LD (HL), $00

	RET

Display_Object:
	LD HL, $mem_object_list
	LD A, $mem_object_load_counter
	INC A
	AND $0f
	LD $mem_object_load_counter, A
	SLA A
	SLA A
	SLA A
	AND $f8
	LD L, A

	LD A, (HL+)
	LD C, A
	LD A, (HL+)
	ADD $80
	LD D, A
	LD A, $mem_viewport_x
	SUB $83
	CP D
	JR NC, =Display_Objects.End
	ADD $0e
	CP D
	JR C, =Display_Objects.End
	LD A, D
	SUB $80
	LD D, A

	LD A, (HL+)
	ADD $80
	LD B, A
	LD A, $mem_viewport_y
	SUB $83
	CP B
	JR NC, =Display_Objects.End
	ADD $0e
	CP B
	JR C, =Display_Objects.End
	LD A, B
	SUB $80
	LD B, A

	LD A, C
	CP $00

	JR Z, =Display_Objects.Nothing

	LD A, D
	CALL =Construct_Tile_Address

	LD A, C
	LD (DE), A

	INC E
	INC C

	LD A, C
	LD (DE), A

	INC C

	LD A, E
	XOR $21
	LD E, A

	LD A, C
	LD (DE), A

	INC C
	INC E

	LD A, C
	LD (DE), A

	Display_Objects.End:
	RET

	Display_Objects.Nothing:
	LD A, D
	CALL =Load_Block
	CALL =Display_Prepared_Block
	RET

Load_Objects:
	CALL =Display_Object
	CALL =Display_Object
	CALL =Display_Object
	CALL =Display_Object
	CALL =Display_Object
	CALL =Display_Object
	CALL =Display_Object
	CALL =Display_Object
	CALL =Display_Object
	CALL =Display_Object
	CALL =Display_Object
	CALL =Display_Object
	CALL =Display_Object
	CALL =Display_Object
	CALL =Display_Object
	CALL =Display_Object
	RET

Object_Interactions_Check:
	LD A, $mem_moving_animation_step
	CP $00
	JR NZ, =.End
	LD A, $mem_map_loading_flags
	BIT 1, A
	JR Z, =.End
	LD HL, $mem_object_list
	LD A, $mem_bunny_x
	LD C, A
	LD A, $mem_bunny_y
	LD B, A
	.loop:
		LD A, (HL+)
		CP $00
		JR Z, =.next

		LD A, (HL+)
		CP C
		JR NZ, =.next

		LD A, (HL+)
		CP B
		JR NZ, =.next

		LD E, (HL)

		PUSH BC

		; So we have HL set to the object pointer
		LD A, L
		AND $f8
		LD L, A

		LD BC, =Object_Interaction_Jump_table
		LD A, E

		.JUMP_TABLE

		POP BC

		.next:
		LD A, L
		AND $f8
		ADD $08
		LD L, A
		CP $80
		JR NZ, =.loop

	.End:
	RET
