Prepare_Entities:
	LD A, $00
	LD $tmp_var_1, A
	LD HL, $mem_entities_list
	CALL =Prepare_Entity
	CALL =Prepare_Entity
	CALL =Prepare_Entity
	CALL =Prepare_Entity
	CALL =Prepare_Entity
	CALL =Prepare_Entity
	CALL =Prepare_Entity
	CALL =Prepare_Entity
	CALL =Prepare_Entity
	CALL =Prepare_Entity
	CALL =Prepare_Entity
	CALL =Prepare_Entity
	CALL =Prepare_Entity
	CALL =Prepare_Entity
	CALL =Prepare_Entity
	CALL =Prepare_Entity
	LD BC, $00a0
	LD HL, $mem_oam_buffer

	LD A, $tmp_var_1
	ADD L
	LD L, A

	LD A, $tmp_var_1
	XOR $ff
	INC A
	ADD C
	LD C, A

	CALL =bzero

	RET

Prepare_Entity:
	LD A, (HL+)
	LD E, A

	CP $00
	JP Z, =Prepare_Entity.skip

	LD A, (HL+)
	ADD $80
	LD D, A
	LD A, $mem_viewport_x
	LD B, A
	SUB $82
	CP D
	JP NC, =Prepare_Entity.skip
	ADD $0e
	CP D
	JP C, =Prepare_Entity.skip
	LD A, D
	SUB $80
	SUB B
	AND $0f
	SWAP A
	LD B, A

	LD A, (HL+)
	ADD $80
	LD D, A
	LD A, $mem_viewport_y
	LD C, A
	SUB $82
	CP D
	JP NC, =Prepare_Entity.skip
	ADD $0d
	CP D
	JP C, =Prepare_Entity.skip
	LD A, D
	SUB $80
	SUB C
	AND $0f
	SWAP A
	ADD $02
	LD C, A

	LD A, $mem_bunny_direction
	BIT 3, A
	JR Z, =Prepare_Entity.Viewport_offset_end
	AND $07
	CP $enum_direction_down
	JR Z, =Prepare_Entity.Viewport_offset_down
	CP $enum_direction_right
	JR Z, =Prepare_Entity.Viewport_offset_right
	CP $enum_direction_up
	JR Z, =Prepare_Entity.Viewport_offset_up

	Prepare_Entity.Viewport_offset_left:
		LD A, $reg_viewport_x
		SUB $08
		AND $0f
		XOR $ff
		ADD $12
		ADD B

		LD B, A
		JR =Prepare_Entity.Viewport_offset_end

	Prepare_Entity.Viewport_offset_right:
		LD A, $reg_viewport_x
		SUB $08
		AND $0f
		XOR $ff
		ADD B

		LD B, A

		JR =Prepare_Entity.Viewport_offset_end

	Prepare_Entity.Viewport_offset_up:
		LD A, $reg_viewport_y
		SUB $08
		AND $0f
		XOR $ff
		ADD $12
		ADD C

		LD C, A

		JR =Prepare_Entity.Viewport_offset_end

	Prepare_Entity.Viewport_offset_down:
		LD A, $reg_viewport_y
		SUB $08
		AND $0f
		XOR $ff
		ADD C

		LD C, A

	Prepare_Entity.Viewport_offset_end:

	LD A, (HL+)
	BIT 3, A
	LD D, A
	LD A, $00
	JR Z, =Prepare_Entity.Not_Moving_Animation

	LD A, D
	AND $07

	CP $enum_direction_down
	JR Z, =Prepare_Entity.moving_offset_down
	CP $enum_direction_right
	JR Z, =Prepare_Entity.moving_offset_right
	CP $enum_direction_up
	JR Z, =Prepare_Entity.moving_offset_up

	Prepare_Entity.moving_offset_left:
		LD A, $mem_moving_animation_step
		XOR $ff
		ADD B
		LD B, A

		JR =Prepare_Entity.moving_offset_end

	Prepare_Entity.moving_offset_right:
		LD A, $mem_moving_animation_step
		INC A
		ADD B
		LD B, A

		JR =Prepare_Entity.moving_offset_end

	Prepare_Entity.moving_offset_up:
		LD A, $mem_moving_animation_step
		XOR $ff
		ADD C
		LD C, A

		JR =Prepare_Entity.moving_offset_end

	Prepare_Entity.moving_offset_down:
		LD A, $mem_moving_animation_step
		INC A
		ADD C
		LD C, A

	Prepare_Entity.moving_offset_end:


	LD A, $mem_moving_animation_step
	Prepare_Entity.Not_Moving_Animation:

	SUB $08
	BIT 7, A
	JR Z, =Prepare_Entity.Hop_ABS1_end

	; Adding hop animation to Y
	XOR $ff
	INC A
	Prepare_Entity.Hop_ABS1_end:
	SUB $04
	BIT 7, A
	JR Z, =Prepare_Entity.Hop_ABS2_end
	XOR $ff
	INC A
	Prepare_Entity.Hop_ABS2_end:
	ADD C

	LD C, A

	LD A, D
	AND $07

	CP $enum_direction_left
	JR Z, =Prepare_Entity.Left_Direction_sprite
	CP $enum_direction_right
	JR Z, =Prepare_Entity.Right_Direction_sprite
	CP $enum_direction_up
	JR Z, =Prepare_Entity.Up_Direction_sprite
	JP =Prepare_Entity.Down_Direction_sprite

	Prepare_Entity.Left_Direction_sprite:
		LD D, $00
		JP =Prepare_Entity.Write_OBJ

	Prepare_Entity.Right_Direction_sprite:
		LD A, $02
		ADD E
		LD E, A
		LD D, $20
		JP =Prepare_Entity.Write_OBJ

	Prepare_Entity.Up_Direction_sprite:
		LD A, $04
		ADD E
		LD E, A
		LD D, $00
		JP =Prepare_Entity.Write_OBJ

	Prepare_Entity.Down_Direction_sprite:
		LD A, $08
		ADD E
		LD E, A
		LD D, $00
		JP =Prepare_Entity.Write_OBJ

	Prepare_Entity.Write_OBJ:
		PUSH HL
		; First OBJ (left)
		LD HL, $mem_oam_buffer
		LD A, $tmp_var_1
		LD L, A
		LD A, C
		LD (HL+), A
		LD A, B
		LD (HL+), A
		LD A, E
		INC A
		LD (HL+), A
		LD A, D
		LD (HL+), A
		
		; Second OBJ
		LD A, B
		ADD $08
		LD B, A

		LD A, C
		LD (HL+), A
		LD A, B
		LD (HL+), A
		LD A, E
		XOR $02
		INC A
		LD (HL+), A
		LD A, D
		LD (HL+), A
		LD A, L
		LD $tmp_var_1, A
		POP HL

	Prepare_Entity.skip:
	LD A, L
	AND $f8
	ADD $08
	LD L, A
	RET

Entities_Behaviours:
	CALL =Reset_Entities_Collision_Map

	LD HL, $mem_entities_list
	CALL =Entity_Behaviour
	CALL =Entity_Behaviour
	CALL =Entity_Behaviour
	CALL =Entity_Behaviour
	CALL =Entity_Behaviour
	CALL =Entity_Behaviour
	CALL =Entity_Behaviour
	CALL =Entity_Behaviour
	CALL =Entity_Behaviour
	CALL =Entity_Behaviour
	CALL =Entity_Behaviour
	CALL =Entity_Behaviour
	CALL =Entity_Behaviour
	CALL =Entity_Behaviour
	CALL =Entity_Behaviour
	CALL =Entity_Behaviour
	RET

Entity_Behaviour:
	LD A, (HL+)
	CP $00
	JR Z, =Entity_Behaviour.skip

	INC HL
	INC HL
	INC HL

	LD A, (HL+)
	LD D, A
	LD A, (HL+)
	LD E, A

	PUSH HL

	LD A, L
	AND $f8
	LD L, A

	; This is confusing but this thing is actually CALL DE
	LD BC, =Entity_Behaviour.interaction_end
	PUSH BC
	PUSH DE
	RET
	Entity_Behaviour.interaction_end:

	POP HL

	Entity_Behaviour.skip:
	LD A, L
	AND $f8
	ADD $08
	LD L, A
	RET

Carve_Entity_Collision_Map: ; X in C, Y in B
	PUSH BC
	PUSH HL
	PUSH AF

	LD A, C
	AND $e0
	JR NZ, =Carve_Entity_Collision_Map.end

	LD A, B
	AND $e0
	JR NZ, =Carve_Entity_Collision_Map.end

	LD A, C

	LD H, $00
	CP $10
	RL B
	AND $0f
	CP $08
	RL B
	AND $07
	LD L, A

	LD A, B
	LD BC, $mem_entities_collisions
	OR C
	LD C, A
	LD A, (BC)

	OR (HL)
	LD (BC), A

	Carve_Entity_Collision_Map.end:

	POP AF
	POP HL
	POP BC
	RET


Get_Position_After_Move: ; entity (whatever alignement) in HL, direction to test in A, X Result in C, Y result in B
	PUSH HL
	PUSH AF

	LD A, L
	AND $f8
	LD L, A

	INC HL

	LD A, (HL+)
	LD C, A
	LD A, (HL+)
	LD B, A

	POP AF
	BIT 3, A
	JR Z, =Get_Position_After_Move.direction_end

	PUSH BC

	DEC A
	LD B, A

	SLA A
	AND $02
	DEC A

	BIT 1, B
	JR NZ, =Get_Position_After_Move.vertical

	Get_Position_After_Move.horizontal:
		POP BC
		ADD C
		LD C, A
		JR =Get_Position_After_Move.direction_end

	Get_Position_After_Move.vertical:
		POP BC
		ADD B
		LD B, A

	Get_Position_After_Move.direction_end:

	POP HL
	RET

Fox_AI:
	PUSH HL

	INC HL
	INC HL
	INC HL

	LD A, $mem_map_loading_flags
	BIT 1, A
	JR Z, =Fox_AI.Update_Position.end

	LD A, (HL)
	BIT 3, A
	JR Z, =Fox_AI.Update_Position.end

	RES 3, A
	DEC A

	LD C, A
	AND $01
	SLA A
	AND $02
	DEC A
	LD B, A

	LD A, L
	AND $f8
	INC A
	LD L, A

	BIT 1, C
	JR NZ, =Fox_AI.vertical_tile_move

	Fox_AI.horizontal_tile_move:
		LD A, (HL)
		ADD B
		LD (HL), A
		JP =Fox_AI.Update_Position.end

	Fox_AI.vertical_tile_move:
		INC HL
		LD A, (HL)
		ADD B
		LD (HL), A

	Fox_AI.Update_Position.end:

	LD A, L
	AND $f8
	ADD $03
	LD L, A

	LD A, $mem_moving_animation_step
	CP $01
	JR NZ, =Fox_AI.end

	LD A, $mem_bunny_direction
	BIT 3, A
	JR Z, =Fox_AI.end

	CALL =RNG_Step
	AND $08
	LD B, A

	LD A, $04
	CALL =RNG_Bound
	INC A
	OR $08
	LD B, A

	PUSH BC
	CALL =Get_Position_After_Move
	LD A, C
	CALL =Is_Collisionable
	CALL =Carve_Entity_Collision_Map
	POP BC
	CP $00
	JR Z, =Fox_AI.change_direction

	RES 3, B

	Fox_AI.change_direction:
	LD (HL), B

	Fox_AI.end:

	POP HL
	RET

Is_Collisionable: ; X in A, Y in B, Result A
	PUSH BC
	PUSH HL

	CP $20
	JR NC, =Is_Collisionable.Solid

	LD C, A
	LD A, B
	CP $20
	JR NC, =Is_Collisionable.Solid
	LD A, C

	LD H, $00
	CP $10
	RL B
	AND $0f
	CP $08
	RL B
	AND $07
	LD L, A

	LD C, B
	LD B, $mem_dungeon_map_high
	LD A, (BC)
	PUSH AF
	LD A, C
	LD BC, $mem_entities_collisions
	OR C
	LD C, A
	LD A, (BC)
	XOR $ff ; 1 in the dungeon map means walkable, 1 in the entity map means unwalkable, we need to invert it.
	LD B, A
	POP AF
	AND B

	AND (HL)
	CP $01
	LD A, $00
	RL A

	POP HL
	POP BC
	RET

	Is_Collisionable.Solid:
	LD A, $01
	POP HL
	POP BC

	RET

Reset_Entities_Collision_Map:
	LD A, $mem_moving_animation_step
	CP $02
	JR NZ, =Reset_Entities_Collision_Map.end

	LD HL, $mem_entities_collisions
	LD BC, $0080
	CALL =bzero

	LD HL, $mem_entities_list
	Reset_Entities_Collision_Map.loop:
		INC L
		INC L
		INC L

		LD A, (HL)
		CALL =Get_Position_After_Move
		CALL =Carve_Entity_Collision_Map

		LD A, L
		AND $f8
		ADD $08
		LD L, A
		CP $00
		JR NZ, =Reset_Entities_Collision_Map.loop

	Reset_Entities_Collision_Map.end:
	RET
