Load_Map:
	LD A, $mem_viewport_x
	SUB $02
	LD C, A
	ADD $10
	LD E, A
	LD A, $mem_viewport_y
	SUB $02
	LD B, A
	ADD $10
	LD D, A
	Load_Map.For_Y:
		Load_Map.For_X:
			LD A, C
			CALL =Load_Block

			INC C
			LD A, C
			CP E
			JR NZ, =Load_Map.For_X

		INC B
		LD A, B
		CP D
		JR NZ, =Load_Map.For_Y

	RET

Load_Row: ; (+1/-1 direction in B)
	PUSH AF
	PUSH BC
	PUSH DE
	LD A, B
	CP $01
	JR NZ, =Load_Row.Up

	LD A, $mem_viewport_y
	ADD $0C
	LD B, A
	JR =Load_Row.Set_X_Limits

	Load_Row.Up:
	LD A, $mem_viewport_y
	SUB $02
	LD B, A

	Load_Row.Set_X_Limits:
	LD A, $mem_viewport_x
	SUB $03
	LD D, A
	LD A, $mem_viewport_x
	ADD $0D
	LD E, A
	Load_Row.For_X:
		LD A, D
		CALL =Load_Block

		INC D
		LD A, D
		CP E
		JR NZ, =Load_Row.For_X

	POP DE
	POP BC
	POP AF
	RET

Load_Column: ; (+1/-1 direction in B)
	PUSH AF
	PUSH BC
	PUSH DE
	LD A, B
	CP $01
	JR NZ, =Load_Column.Left

	LD A, $mem_viewport_x
	ADD $0C
	LD D, A
	JR =Load_Column.Set_Y_Limits

	Load_Column.Left:
	LD A, $mem_viewport_x
	SUB $02
	LD D, A

	Load_Column.Set_Y_Limits:
	LD A, $mem_viewport_y
	SUB $03
	LD B, A
	LD A, $mem_viewport_y
	ADD $0D
	LD E, A
	Load_Column.For_Y:
		LD A, D
		CALL =Load_Block

		INC B
		LD A, B
		CP E
		JR NZ, =Load_Column.For_Y

	POP DE
	POP BC
	POP AF
	RET

Load_Block: ; X in A, Y in B
	PUSH BC
	PUSH AF
	PUSH DE

	; Construct Tile Map address from A and B in DE
	PUSH AF
	PUSH BC

	AND $0f
	LD C, A
	LD A, B
	AND $0f
	LD B, A
	LD A, C

	LD D, $00
	LD E, $00
	LD E, B
	SWAP E
	SLA E
	RL D
	SLA E
	RL D
	SLA A
	OR E
	LD E, A
 	LD A, D
	OR $98
	LD D, A
	POP BC
	POP AF

	PUSH AF
	PUSH DE

	LD C, $00
	LD D, A

	; Checking down block
	LD A, D
	INC B
	CALL =Is_Solid
	OR C
	LD C, A
	DEC B
	SLA C

	; Checking up block
	LD A, D
	DEC B
	CALL =Is_Solid
	OR C
	LD C, A
	INC B
	SLA C

	; Checking right block
	LD A, D
	INC A
	CALL =Is_Solid
	OR C
	LD C, A
	SLA C

	; Checking left block
	LD A, D
	DEC A
	CALL =Is_Solid
	OR C
	LD C, A
	SLA C

	SLA C

	LD A, C
	ADD $20
	LD C, A

	POP DE
	POP AF

	CALL =Is_Solid

	CP $00
	JR Z, =Load_Block.Empty
	Load_Block.Solid:
		LD A, C
		LD (DE), A
		LD A, E
		OR $20
		LD E, A
		LD A, C
		OR $02
		LD (DE), A
		INC E
		LD A, C
		OR $03
		LD (DE), A
		LD A, E
		AND $DF
		LD E, A
		LD A, C
		OR $01
		LD (DE), A

		JR =Load_Block.End

	Load_Block.Empty:
		LD A, $00
		LD (DE), A
		LD A, E
		OR $20
		LD E, A
		LD A, $00
		LD (DE), A
		INC E
		LD A, $00
		LD (DE), A
		LD A, E
		AND $DF
		LD E, A
		LD A, $00
		LD (DE), A

	Load_Block.End:

	POP DE
	POP AF
	POP BC
	RET

Initial_dungeon:
	.DB $00, $00, $00, $00,
	.DB $00, $00, $00, $00,
	.DB $00, $00, $00, $00,
	.DB $00, $00, $00, $00,
	.DB $00, $00, $00, $00,
	.DB $00, $00, $00, $00,
	.DB $00, $00, $00, $00,
	.DB $03, $e0, $00, $00,
	.DB $02, $20, $00, $00,
	.DB $02, $20, $00, $00,
	.DB $02, $20, $00, $00,
	.DB $02, $20, $00, $00,
	.DB $02, $20, $00, $00,
	.DB $0e, $20, $00, $00,
	.DB $3f, $20, $00, $00,
	.DB $3f, $20, $00, $00,
	.DB $3f, $3f, $80, $00,
	.DB $3f, $00, $80, $00,
	.DB $3f, $00, $80, $00,
	.DB $3f, $00, $80, $00,
	.DB $3f, $00, $80, $00,
	.DB $3f, $00, $80, $00,
	.DB $00, $01, $f8, $00,
	.DB $00, $01, $f8, $00,
	.DB $00, $01, $f8, $00,
	.DB $00, $01, $f8, $00,
	.DB $00, $01, $f8, $00,
	.DB $00, $01, $ff, $80,
	.DB $00, $01, $f8, $80,
	.DB $00, $01, $f8, $80,
	.DB $00, $00, $ff, $80,
	.DB $00, $00, $00, $00,

Initialize_Dungeon:
	LD HL, $mem_dungeon_map
	LD DE, =Initial_dungeon
	LD BC, $0100
	JP =memcpy


Is_Solid: ; X in A, Y in B, Result A
	PUSH BC

	CP $20
	JR NC, =Is_Solid.Solid

	LD C, A
	LD A, B
	CP $20
	JR NC, =Is_Solid.Solid
	LD A, C

	LD H, $00
	CP $10
	RL B
	AND $0f
	CP $08
	RL B
	AND $07
	LD L, A

	LD C, B
	LD B, $c8
	LD A, (BC)

	AND (HL)
	CP $01
	LD A, $00
	RL A

	POP BC
 	RET

	Is_Solid.Solid:
	LD A, $01
	POP BC

	RET
