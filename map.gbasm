Load_Map:
	LD C, $fd
	LD B, $fd
	Load_Map.For_Y:
		Load_Map.For_X:
			LD A, C
			CALL =Load_Block

			INC C
			LD A, C
			CP $0d
			JR NZ, =Load_Map.For_X

		INC B
		LD A, B
		CP $0d
		JR NZ, =Load_Map.For_Y

	RET

Load_Row: ; (+1/-1 direction in B)
	PUSH AF
	PUSH BC
	PUSH DE
	LD A, B
	CP $01
	JR NZ, =Load_Row.Up

	LD A, $mem_viewport_y
	ADD $0C
	LD B, A
	JR =Load_Row.Set_X_Limits

	Load_Row.Up:
	LD A, $mem_viewport_y
	SUB $02
	LD B, A

	Load_Row.Set_X_Limits:
	LD A, $mem_viewport_x
	SUB $03
	LD D, A
	LD A, $mem_viewport_x
	ADD $0D
	LD E, A
	Load_Row.For_X:
		LD A, D
		CALL =Load_Block

		INC D
		LD A, D
		CP E
		JR NZ, =Load_Row.For_X

	POP DE
	POP BC
	POP AF
	RET

Load_Column: ; (+1/-1 direction in B)
	PUSH AF
	PUSH BC
	PUSH DE
	LD A, B
	CP $01
	JR NZ, =Load_Column.Left

	LD A, $mem_viewport_x
	ADD $0C
	LD D, A
	JR =Load_Column.Set_Y_Limits

	Load_Column.Left:
	LD A, $mem_viewport_x
	SUB $02
	LD D, A

	Load_Column.Set_Y_Limits:
	LD A, $mem_viewport_y
	SUB $03
	LD B, A
	LD A, $mem_viewport_y
	ADD $0D
	LD E, A
	Load_Column.For_Y:
		LD A, D
		CALL =Load_Block

		INC B
		LD A, B
		CP E
		JR NZ, =Load_Column.For_Y

	POP DE
	POP BC
	POP AF
	RET

Load_Block: ; X in A, Y in B (X and B being AND with 0x0f)
	PUSH BC
	PUSH AF
	PUSH DE

	; Construct Tile Map address from A and B in DE
	PUSH AF
	PUSH BC

	AND $0f
	LD C, A
	LD A, B
	AND $0f
	LD B, A
	LD A, C

	LD D, $00
	LD E, $00
	LD E, B
	SWAP E
	SLA E
	RL D
	SLA E
	RL D
	SLA A
	OR E
	LD E, A
 	LD A, D
	OR $98
	LD D, A
	POP BC
	POP AF

	PUSH AF
	PUSH DE

	LD C, $00
	LD D, A

	; Checking down block
	LD A, D
	INC B
	CALL =Is_Solid
	OR C
	LD C, A
	DEC B
	SLA C

	; Checking up block
	LD A, D
	DEC B
	CALL =Is_Solid
	OR C
	LD C, A
	INC B
	SLA C

	; Checking right block
	LD A, D
	INC A
	CALL =Is_Solid
	OR C
	LD C, A
	SLA C

	; Checking left block
	LD A, D
	DEC A
	CALL =Is_Solid
	OR C
	LD C, A
	SLA C

	SLA C

	LD A, C
	ADD $20
	LD C, A

	POP DE
	POP AF

	CALL =Is_Solid

	CP $00
	JR Z, =Load_Block.Empty
	Load_Block.Solid:
		LD A, C
		LD (DE), A
		LD A, E
		OR $20
		LD E, A
		LD A, C
		OR $02
		LD (DE), A
		INC E
		LD A, C
		OR $03
		LD (DE), A
		LD A, E
		AND $DF
		LD E, A
		LD A, C
		OR $01
		LD (DE), A

		JR =Load_Block.End

	Load_Block.Empty:
		LD A, $00
		LD (DE), A
		LD A, E
		OR $20
		LD E, A
		LD A, $00
		LD (DE), A
		INC E
		LD A, $00
		LD (DE), A
		LD A, E
		AND $DF
		LD E, A
		LD A, $00
		LD (DE), A

	Load_Block.End:

	POP DE
	POP AF
	POP BC
	RET

; Is_Solid: ; X in A, Y in B, Result A
; 	PUSH BC
; 	PUSH DE
; 	PUSH HL
; 	LD C, A
; 
; 	LD D, $00 ; Constructed room number
; 	LD E, $00 ; Depth
; 	PUSH DE
; 
; 	Is_Solid.Corridor.loop:
; 		LD HL, $mem_corridors_array
; 		POP DE
; 		LD A, D
; 		PUSH DE
; 		SLA A
; 		SLA A
; 		SLA A
; 		OR L
; 		LD L, A
; 		
; 		LD A, (HL+)
; 		CP $00 ; 0 is horizontal
; 		JR Z, =Is_Solid.Corridor.horizontal
; 
; 		Is_Solid.Corridor.vertical:	
; 			JR =Is_Solid.Corridor.next
; 
; 		Is_Solid.Corridor.horizontal:
; 			LD A, (HL+)
; 			LD D, A
; 			LD A, (HL+)
; 			LD E, A
; 			LD A, (HL+)
; 			CP B
; 			JR NZ, =Is_Solid.Corridor.room_update
; 			LD C, A
; 			CP D
; 			JR C, =Is_Solid.Corridor.room_update
; 			CP E
; 			JR C, =Is_Solid.NotSolid
; 
; 			Is_Solid.Corridor.room_update:
; 			LD A, (HL+) 
; 			CP C
; 			LD A, $00
; 			ADC $00
; 			POP DE
; 			SLA D
; 			OR A
; 			LD D, A
; 			PUSH DE
; 
; 			JR =Is_Solid.Corridor.next
; 
; 		Is_Solid.Corridor.next:
; 		POP DE
; 		INC E
; 		LD A, E
; 		PUSH DE
; 		CP $04
; 		JR NZ =Is_Solid.Corridor.loop
; 
; 	POP DE
; 	LD A, $01
; 	JR =Is_Solid.End
; 
; 	Is_Solid.NotSolid:
; 	POP DE
; 	LD A, $00
; 	Is_Solid.End:
; 
; 	POP BC
; 	POP DE
; 	POP HL
; 	RET

Initialize_Room:
	LD HL, $mem_room_array
	LD A, $00
	LD (HL+), A 
	LD A, $20
	LD (HL+), A
	LD A, $00
	LD (HL+), A
	LD A, $20
	LD (HL+), A
	RET

Is_Solid: ; X in A, Y in B, Result A
; 	AND $0f
; 	JR Z, =Is_Solid.Solid
; 	LD A, B
; 	AND $07
; 	JR Z, =Is_Solid.Solid
; 
; 
; 	Is_Solid.NonSolid:
; 		LD A, $00
; 		JR =Is_Solid.End
; 
; 	Is_Solid.Solid:
; 		LD A, $01
; 
; 	Is_Solid.End:
; 	RET
 	PUSH BC
 	PUSH DE
 	PUSH HL
 
 	LD C, A
 	LD DE, $mem_room_array
 
 	Is_Solid.room_loop:
 		LD H, D
 		LD L, E
 
 		LD A, (HL+)
 		CP C
 		JR NC, =Is_Solid.room_loop.next
 
 		LD A, (HL+)
 		CP C
 		JR C, =Is_Solid.room_loop.next
 
 		LD A, (HL+)
 		CP B
 		JR NC, =Is_Solid.room_loop.next
 
 		LD A, (HL+)
 		CP B
 		JR NC, =Is_Solid.NonSolid
 
 	Is_Solid.room_loop.next:
 		LD A, $04
 		ADD E
 		LD E, A
 		CP $40
 		JR NZ, =Is_Solid.room_loop
 
 	LD A, $01
 	JR =Is_Solid.End
 
 	Is_Solid.NonSolid:
 	LD A, $00
 
 	Is_Solid.End:
 	POP HL
 	POP DE
 	POP BC
 	RET
